"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const config_1 = require("@nomiclabs/buidler/config");
const compiler_1 = require("@nomiclabs/buidler/internal/solidity/compiler");
const strings_1 = require("@nomiclabs/buidler/internal/util/strings");
const artifacts_1 = require("@nomiclabs/buidler/internal/artifacts");
const task_names_1 = require("@nomiclabs/buidler/builtin-tasks/task-names");
config_1.internalTask(task_names_1.TASK_COMPILE_RUN_COMPILER).setAction(async ({ input }, { config }) => {
    let ovmSolcJs;
    try {
        ovmSolcJs = require('@eth-optimism/solc');
    }
    catch (err) {
        if (err.toString().contains('Cannot find module')) {
            throw new Error(`ovm-toolchain: Could not find "@eth-optimism/solc" in your node_modules.`);
        }
        else {
            throw err;
        }
    }
    const evmCompiler = new compiler_1.Compiler(config.solc.version, path.join(config.paths.cache, 'compilers'));
    const ovmCompiler = new compiler_1.Compiler(ovmSolcJs.version(), path.join(config.paths.cache, 'compilers'));
    ovmCompiler.getSolc = () => {
        return ovmSolcJs;
    };
    const ovmInput = {
        language: 'Solidity',
        sources: {},
        settings: input.settings,
    };
    const evmInput = {
        language: 'Solidity',
        sources: {},
        settings: input.settings,
    };
    for (const file of Object.keys(input.sources)) {
        evmInput.sources[file] = input.sources[file];
        if (input.sources[file].content.includes('// +build ovm')) {
            ovmInput.sources[file] = input.sources[file];
        }
    }
    console.log('Compiling ovm contracts...');
    const ovmOutput = await ovmCompiler.compile(ovmInput);
    console.log('Compiling evm contracts...');
    const evmOutput = await evmCompiler.compile(evmInput);
    let errors = (ovmOutput.errors || []).concat(evmOutput.errors || []);
    const filtered = errors.filter((error) => {
        return error.message !== 'No input sources specified.';
    });
    if (errors.length === filtered.length + 1) {
        errors = filtered;
    }
    for (const name of Object.keys(ovmOutput.contracts)) {
        ovmOutput.contracts[`${name}.ovm`] = ovmOutput.contracts[name];
        delete ovmOutput.contracts[name];
    }
    const output = {
        contracts: Object.assign(Object.assign({}, ovmOutput.contracts), evmOutput.contracts),
        errors,
        sources: Object.assign(Object.assign({}, ovmOutput.sources), evmOutput.sources),
    };
    return output;
});
config_1.internalTask(task_names_1.TASK_COMPILE_GET_COMPILER_INPUT, async (_, { config, run }, runSuper) => {
    const input = await runSuper();
    input.settings.outputSelection['*']['*'].push('storageLayout');
    return input;
});
config_1.internalTask(task_names_1.TASK_BUILD_ARTIFACTS, async ({ force }, { config, run }) => {
    const sources = await run(task_names_1.TASK_COMPILE_GET_SOURCE_PATHS);
    if (sources.length === 0) {
        console.log('No Solidity source file available.');
        return;
    }
    const isCached = await run(task_names_1.TASK_COMPILE_CHECK_CACHE, { force });
    if (isCached) {
        console.log('All contracts have already been compiled, skipping compilation.');
        return;
    }
    const compilationOutput = await run(task_names_1.TASK_COMPILE_COMPILE);
    if (compilationOutput === undefined) {
        return;
    }
    await fs_extra_1.default.ensureDir(config.paths.artifacts);
    let numberOfContracts = 0;
    for (const [fileName, file] of Object.entries(compilationOutput.contracts)) {
        for (const [contractName, contractOutput] of Object.entries(file)) {
            const artifact = artifacts_1.getArtifactFromContractOutput(contractName, contractOutput);
            numberOfContracts += 1;
            artifact.storageLayout = contractOutput.storageLayout;
            if (fileName.endsWith('.ovm')) {
                await artifacts_1.saveArtifact(config.paths.artifacts + '/ovm', artifact);
            }
            else {
                await artifacts_1.saveArtifact(config.paths.artifacts, artifact);
            }
        }
    }
    console.log('Compiled', numberOfContracts, strings_1.pluralize(numberOfContracts, 'contract'), 'successfully');
});
//# sourceMappingURL=ovm-compiler.js.map