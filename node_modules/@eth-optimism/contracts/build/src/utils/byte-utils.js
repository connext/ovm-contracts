"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.add0x = exports.numberToHexString = exports.hexStrToBuf = exports.isHexString = exports.remove0x = exports.makeAddress = exports.makeHexString = void 0;
const hexRegex = /^(0x)?[0-9a-fA-F]*$/;
exports.makeHexString = (byte, len) => {
    return '0x' + byte.repeat(len);
};
exports.makeAddress = (byte) => {
    return exports.makeHexString(byte, 20);
};
exports.remove0x = (str) => {
    if (str.startsWith('0x')) {
        return str.slice(2);
    }
    else {
        return str;
    }
};
exports.isHexString = (str) => {
    return hexRegex.test(str);
};
exports.hexStrToBuf = (hexString) => {
    if (!exports.isHexString(hexString)) {
        throw new RangeError(`Invalid hex string [${hexString}]`);
    }
    if (hexString.length % 2 !== 0) {
        throw new RangeError(`Invalid hex string -- odd number of characters: [${hexString}]`);
    }
    return Buffer.from(exports.remove0x(hexString), 'hex');
};
exports.numberToHexString = (number, padToBytes = -1) => {
    let str = number.toString(16);
    if (padToBytes > 0 || str.length < padToBytes * 2) {
        str = `${'0'.repeat(padToBytes * 2 - str.length)}${str}`;
    }
    return exports.add0x(str);
};
exports.add0x = (str) => {
    if (str === undefined) {
        return str;
    }
    return str.startsWith('0x') ? str : '0x' + str;
};
//# sourceMappingURL=byte-utils.js.map