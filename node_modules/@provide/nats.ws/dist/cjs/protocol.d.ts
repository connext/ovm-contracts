import { ClientHandlers, ConnectionOptions, Callback, ErrorCallback, Msg, Req, Sub } from "./types";
import { Transport, TransportHandlers } from "./transport";
import { NatsError } from "./error";
import { DataBuffer } from "./databuffer";
export declare enum ParserState {
    CLOSED = -1,
    AWAITING_CONTROL = 0,
    AWAITING_MSG_PAYLOAD = 1
}
export declare function createInbox(): string;
export declare class Connect {
    auth_token?: string;
    echo?: boolean;
    jwt?: string;
    lang: string;
    name?: string;
    pass?: string;
    pedantic: boolean;
    protocol: number;
    user?: string;
    verbose: boolean;
    constructor(opts?: ConnectionOptions);
}
export declare function defaultSub(): Sub;
export declare function defaultReq(): Req;
export declare class Request {
    token: string;
    private protocol;
    constructor(req: Req, protocol: ProtocolHandler);
    cancel(): void;
}
export declare class Subscription {
    sid: number;
    private protocol;
    constructor(sub: Sub, protocol: ProtocolHandler);
    unsubscribe(max?: number): void;
    hasTimeout(): boolean;
    cancelTimeout(): void;
    setTimeout(millis: number, cb: Callback): boolean;
    getReceived(): number;
    drain(): Promise<any>;
    isDraining(): boolean;
    isCancelled(): boolean;
}
export declare class MuxSubscription {
    baseInbox: string;
    reqs: {
        [key: string]: Req;
    };
    length: number;
    init(): string;
    add(r: Req): void;
    get(token: string): Req | null;
    cancel(r: Req): void;
    getToken(m: Msg): string | null;
    dispatcher(): (m: Msg) => void;
}
export declare class Subscriptions {
    mux: Sub;
    subs: {
        [key: number]: Sub;
    };
    sidCounter: number;
    length: number;
    add(s: Sub): Sub;
    setMux(s: Sub): Sub;
    getMux(): Sub | null;
    get(sid: number): (Sub | null);
    all(): (Sub)[];
    cancel(s: Sub): void;
}
export declare class MsgBuffer {
    msg: Msg;
    length: number;
    buf?: ArrayBuffer | null;
    payload: string;
    constructor(chunks: RegExpExecArray, payload?: "string" | "json" | "binary");
    fill(data: ArrayBuffer): void;
}
export declare class ProtocolHandler implements TransportHandlers {
    clientHandlers: ClientHandlers;
    connectError: ErrorCallback | null;
    inbound: DataBuffer;
    infoReceived: boolean;
    muxSubscriptions: MuxSubscription;
    options: ConnectionOptions;
    outbound: DataBuffer;
    payload: MsgBuffer | null;
    pongs: Array<Function | undefined>;
    pout: number;
    state: ParserState;
    subscriptions: Subscriptions;
    transport: Transport;
    noMorePublishing: boolean;
    constructor(options: ConnectionOptions, handlers: ClientHandlers);
    static connect(options: ConnectionOptions, handlers: ClientHandlers): Promise<ProtocolHandler>;
    static toError(s: string): NatsError;
    processInbound(): void;
    processMsg(): void;
    sendCommand(cmd: string | ArrayBuffer): void;
    publish(subject: string, data: ArrayBuffer, reply: string): void;
    request(r: Req): Request;
    subscribe(s: Sub): Subscription;
    unsubscribe(sid: number, max?: number): void;
    cancelRequest(token: string, max?: number): void;
    flush(f?: Function): void;
    processError(s: string): void;
    sendSubscriptions(): void;
    openHandler(_: Event): void;
    closeHandler(_: CloseEvent): void;
    errorHandler(evt: Event | Error): void;
    messageHandler(evt: MessageEvent): void;
    close(): void;
    isClosed(): boolean;
    drain(): Promise<any>;
    drainSubscription(sid: number): Promise<Sub>;
    private flushPending;
    private initMux;
    private handleError;
}
//# sourceMappingURL=protocol.d.ts.map