"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ErrorCode;
(function (ErrorCode) {
    ErrorCode["BAD_AUTHENTICATION"] = "BAD_AUTHENTICATION";
    ErrorCode["BAD_SUBJECT"] = "BAD_SUBJECT";
    ErrorCode["CONNECTION_CLOSED"] = "CONNECTION_CLOSED";
    ErrorCode["CONNECTION_DRAINING"] = "CONNECTION_DRAINING";
    ErrorCode["CONNECTION_REFUSED"] = "CONNECTION_REFUSED";
    ErrorCode["CONNECTION_TIMEOUT"] = "CONNECTION_TIMEOUT";
    ErrorCode["INVALID_PAYLOAD_TYPE"] = "INVALID_PAYLOAD";
    ErrorCode["UNKNOWN"] = "UNKNOWN_ERROR";
    ErrorCode["WSS_REQUIRED"] = "WSS_REQUIRED";
    ErrorCode["SUB_CLOSED"] = "SUB_CLOSED";
    ErrorCode["SUB_DRAINING"] = "SUB_DRAINING";
    ErrorCode["PERMISSIONS_VIOLATION"] = "PERMISSIONS_VIOLATION";
    ErrorCode["AUTHORIZATION_VIOLATION"] = "AUTHORIZATION_VIOLATION";
    ErrorCode["NATS_PROTOCOL_ERR"] = "NATS_PROTOCOL_ERR";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
class Messages {
    constructor() {
        this.messages = {};
        this.messages[ErrorCode.BAD_AUTHENTICATION] = "User and Token can not both be provided";
        this.messages[ErrorCode.BAD_SUBJECT] = "Subject must be supplied";
        this.messages[ErrorCode.CONNECTION_CLOSED] = "Connection closed";
        this.messages[ErrorCode.CONNECTION_CLOSED] = "Connection closed";
        this.messages[ErrorCode.CONNECTION_REFUSED] = "Connection refused";
        this.messages[ErrorCode.CONNECTION_TIMEOUT] = "Connection timeout";
        this.messages[ErrorCode.CONNECTION_DRAINING] = "Connection draining";
        this.messages[ErrorCode.INVALID_PAYLOAD_TYPE] = "Invalid payload type - payloads can be 'binary', 'string', or 'json'";
        this.messages[ErrorCode.SUB_CLOSED] = 'Subscription closed';
        this.messages[ErrorCode.SUB_DRAINING] = 'Subscription draining';
        this.messages[ErrorCode.WSS_REQUIRED] = "TLS is required, therefore a secure websocket connection is also required";
    }
    static getMessage(s) {
        return Messages.messages.getMessage(s);
    }
    getMessage(s) {
        let v = this.messages[s];
        if (!v) {
            v = s;
        }
        return v;
    }
}
exports.Messages = Messages;
Messages.messages = new Messages();
class NatsError extends Error {
    constructor(message, code, chainedError) {
        super(message);
        this.name = "NatsError";
        this.message = message;
        this.code = code;
        this.chainedError = chainedError;
    }
    static errorForCode(code, chainedError) {
        let m = Messages.getMessage(code);
        return new NatsError(m, code, chainedError);
    }
}
exports.NatsError = NatsError;
//# sourceMappingURL=error.js.map