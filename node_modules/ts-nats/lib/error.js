"use strict";
/*
 * Copyright 2018-2020 The NATS Authors
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const util = __importStar(require("util"));
var ErrorCode;
(function (ErrorCode) {
    ErrorCode["API_ERROR"] = "API_ERROR";
    ErrorCode["BAD_AUTHENTICATION"] = "BAD_AUTHENTICATION";
    ErrorCode["BAD_CREDS"] = "BAD_CREDENTIALS";
    ErrorCode["BAD_JSON"] = "BAD_JSON";
    ErrorCode["BAD_MSG"] = "BAD_MSG";
    ErrorCode["BAD_NKEY_SEED"] = "BAD_NKEY_CREDENTIALS";
    ErrorCode["BAD_REPLY"] = "BAD_REPLY";
    ErrorCode["BAD_SUBJECT"] = "BAD_SUBJECT";
    ErrorCode["CLIENT_CERT_REQ"] = "CLIENT_CERT_REQ";
    ErrorCode["CONN_CLOSED"] = "CONN_CLOSED";
    ErrorCode["CONN_DRAINING"] = "CONN_DRAINING";
    ErrorCode["CONN_ERR"] = "CONN_ERR";
    ErrorCode["CONN_TIMEOUT"] = "CONN_TIMEOUT";
    ErrorCode["INVALID_ENCODING"] = "INVALID_ENCODING";
    ErrorCode["NKEY_OR_JWT_REQ"] = "NKEY_OR_JWT_REQ";
    ErrorCode["NONCE_SIGNER_NOTFUNC"] = "NONCE_SIGNER_NOT_FUNC";
    ErrorCode["NON_SECURE_CONN_REQ"] = "NON_SECURE_CONN_REQ";
    ErrorCode["NO_ECHO_NOT_SUPPORTED"] = "NO_ECHO_NOT_SUPPORTED";
    ErrorCode["NO_SEED_IN_CREDS"] = "NO_SEED_IN_CREDS";
    ErrorCode["NO_USER_JWT_IN_CREDS"] = "NO_USER_JWT_IN_CREDS";
    ErrorCode["REQ_TIMEOUT"] = "REQ_TIMEOUT";
    ErrorCode["SECURE_CONN_REQ"] = "SECURE_CONN_REQ";
    ErrorCode["SIGNATURE_REQUIRED"] = "SIG_REQ";
    ErrorCode["SSL_ERR"] = "SSL_ERR";
    ErrorCode["STALE_CONNECTION_ERR"] = "STALE CONNECTION";
    ErrorCode["SUB_CLOSED"] = "SUB_CLOSED";
    ErrorCode["SUB_DRAINING"] = "SUB_DRAINING";
    ErrorCode["SUB_TIMEOUT"] = "SUB_TIMEOUT";
    ErrorCode["UNABLE_TO_CONNECT"] = "UNABLE_TO_CONNECT";
    // emitted by the server
    ErrorCode["AUTHORIZATION_VIOLATION"] = "AUTHORIZATION_VIOLATION";
    ErrorCode["NATS_PROTOCOL_ERR"] = "NATS_PROTOCOL_ERR";
    ErrorCode["PERMISSIONS_VIOLATION"] = "PERMISSIONS_VIOLATION";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
// Error templates
exports.REQ_TIMEOUT_MSG_PREFIX = 'The request timed out for subscription id: ';
exports.INVALID_ENCODING_MSG_PREFIX = 'Invalid Encoding:';
exports.CONN_ERR_PREFIX = 'Could not connect to server: ';
class Messages {
    constructor() {
        this.messages = {};
        this.messages[ErrorCode.BAD_AUTHENTICATION] = 'User and Token can not both be provided';
        this.messages[ErrorCode.BAD_CREDS] = 'Bad user credentials';
        this.messages[ErrorCode.BAD_JSON] = 'Message should be a non-circular JSON-serializable value';
        this.messages[ErrorCode.BAD_MSG] = 'Message cannot be a function';
        this.messages[ErrorCode.BAD_NKEY_SEED] = 'Bad nkey credentials';
        this.messages[ErrorCode.BAD_REPLY] = 'Reply cannot be a function';
        this.messages[ErrorCode.BAD_SUBJECT] = 'Subject must be supplied';
        this.messages[ErrorCode.CLIENT_CERT_REQ] = 'Server requires a client certificate.';
        this.messages[ErrorCode.CONN_CLOSED] = 'Connection closed';
        this.messages[ErrorCode.CONN_DRAINING] = 'Connection draining';
        this.messages[ErrorCode.CONN_TIMEOUT] = 'Connection timeout';
        this.messages[ErrorCode.NKEY_OR_JWT_REQ] = 'An Nkey or User JWT callback is required.';
        this.messages[ErrorCode.NONCE_SIGNER_NOTFUNC] = 'nonce signer is not a function';
        this.messages[ErrorCode.NON_SECURE_CONN_REQ] = 'Server does not support a secure connection.';
        this.messages[ErrorCode.NON_SECURE_CONN_REQ] = 'Server does not support a secure connection.';
        this.messages[ErrorCode.NO_ECHO_NOT_SUPPORTED] = 'No echo option is not supported by this server';
        this.messages[ErrorCode.NO_SEED_IN_CREDS] = 'Cannot locate signing key in credentials';
        this.messages[ErrorCode.NO_USER_JWT_IN_CREDS] = 'Cannot locate user jwt in credentials.';
        this.messages[ErrorCode.NON_SECURE_CONN_REQ] = 'Server does not support a secure connection.';
        this.messages[ErrorCode.NONCE_SIGNER_NOTFUNC] = 'nonce signer is not a function';
        this.messages[ErrorCode.REQ_TIMEOUT] = 'Request timed out.';
        this.messages[ErrorCode.SECURE_CONN_REQ] = 'Server requires a secure connection.';
        this.messages[ErrorCode.SIGNATURE_REQUIRED] = 'Server requires an nkey signature.';
        this.messages[ErrorCode.SSL_ERR] = 'TLS credentials verification failed';
        this.messages[ErrorCode.SUB_CLOSED] = 'Subscription closed';
        this.messages[ErrorCode.SUB_DRAINING] = 'Subscription draining';
        this.messages[ErrorCode.SUB_TIMEOUT] = 'Subscription timed out.';
        this.messages[ErrorCode.UNABLE_TO_CONNECT] = 'Unable to connect.';
    }
    static getMessage(s) {
        return Messages.messages.getMessage(s);
    }
    getMessage(s) {
        let v = this.messages[s];
        if (!v) {
            v = s;
        }
        return v;
    }
}
exports.Messages = Messages;
Messages.messages = new Messages();
class NatsError {
    /**
     * @param {String} message
     * @param {String} code
     * @param {Error} [chainedError]
     * @constructor
     *
     * @api private
     */
    constructor(message, code, chainedError) {
        Error.captureStackTrace(this, this.constructor);
        this.name = 'NatsError';
        this.message = message;
        this.code = code;
        this.chainedError = chainedError;
        util.inherits(NatsError, Error);
    }
    static errorForCode(code, chainedError) {
        let m = Messages.getMessage(code);
        return new NatsError(m, code, chainedError);
    }
}
exports.NatsError = NatsError;
//# sourceMappingURL=error.js.map