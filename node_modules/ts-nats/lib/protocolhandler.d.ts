/// <reference types="node" />
import { Client, FlushCallback, NatsConnectionOptions, Req, ServerInfo, Sub, SubEvent, Subscription } from './nats';
import { MuxSubscriptions } from './muxsubscriptions';
import { NatsError } from './error';
import { EventEmitter } from 'events';
import { Server } from './servers';
import { Subscriptions } from './subscriptions';
/**
 * @hidden
 */
export declare class ProtocolHandler extends EventEmitter {
    options: NatsConnectionOptions;
    subscriptions: Subscriptions;
    muxSubscriptions: MuxSubscriptions;
    private client;
    private closed;
    private connected;
    private currentServer;
    private encoding;
    private inbound;
    private info;
    private infoReceived;
    private msgBuffer?;
    private outbound;
    private payload;
    private pingTimer?;
    private pongs;
    private pout;
    private reconnecting;
    private servers;
    private ssid;
    private state;
    private transport;
    private url;
    private wasConnected;
    private draining;
    private noMorePublishing;
    private connectionTimer?;
    constructor(client: Client, options: NatsConnectionOptions);
    static connect(client: Client, opts: NatsConnectionOptions): Promise<ProtocolHandler>;
    startHandshakeTimeout(): void;
    flush(cb: FlushCallback): void;
    closeAndEmit(): void;
    close(): void;
    drain(): Promise<any>;
    publish(subject: string, data: any, reply?: string): void;
    subscribe(s: Sub): Subscription;
    drainSubscription(sid: number): Promise<SubEvent>;
    unsubscribe(sid: number, max?: number): void;
    request(r: Req): Request;
    numSubscriptions(): number;
    isClosed(): boolean;
    cancelRequest(token: string, max?: number): void;
    private connect;
    private flushPending;
    private static buildProtocolMessage;
    private sendCommand;
    private getTransportHandlers;
    private prepareConnection;
    getInfo(): ServerInfo | null;
    /**
     * Strips all SUBS commands from pending during initial connection completed since
     * we send the subscriptions as a separate operation.
     *
     * @api private
     */
    private stripPendingSubs;
    /**
     * Sends existing subscriptions to new server after reconnect.
     *
     * @api private
     */
    private sendSubscriptions;
    /**
     * Process the inbound data queue.
     *
     * @api private
     */
    private processInbound;
    private clientTLSRequirement;
    /**
     * Check for TLS configuration mismatch.
     *
     * @api private
     */
    private checkTLSMismatch;
    /**
     * Check no echo
     * @api private
     */
    private checkNoEchoMismatch;
    private checkNonceSigner;
    private getNkeyCreds;
    private getUserCreds;
    private nkeyNonceSigner;
    private credsNonceSigner;
    private loadJwt;
    /**
     * Process a delivered message and deliver to appropriate subscriber.
     *
     * @api private
     */
    private processMsg;
    static toError(s: string): NatsError;
    /**
     * ProcessErr processes any error messages from the server
     * Return true if the error closed the connection
     * @api private
     */
    private processErr;
    /**
     * Close down the stream and clear state.
     *
     * @api private
     */
    private closeStream;
    /**
     * Setup a timer event to attempt reconnect.
     *
     * @api private
     */
    private scheduleReconnect;
    private scheduleHeartbeat;
    private cancelHeartbeat;
    /**
     * Reconnect to the server.
     *
     * @api private
     */
    private reconnect;
    /**
     * Properly select the next server.
     * We rotate the server list as we go,
     * we also pull auth from urls as needed, or
     * if they were set in options use that as override.
     *
     * @api private
     */
    private selectServer;
    private toBuffer;
    private initMux;
    /**
     * Callback for first flush/connect.
     *
     * @api private
     */
    private connectCB;
}
export declare class Request {
    token: string;
    private protocol;
    constructor(req: Req, protocol: ProtocolHandler);
    cancel(): void;
}
export declare class Connect {
    lang: string;
    version: string;
    verbose: boolean;
    pedantic: boolean;
    protocol: number;
    user?: string;
    pass?: string;
    auth_token?: string;
    name?: string;
    echo?: boolean;
    sig?: string;
    jwt?: string;
    nkey?: string;
    constructor(server: Server, opts: NatsConnectionOptions, info: ServerInfo);
}
