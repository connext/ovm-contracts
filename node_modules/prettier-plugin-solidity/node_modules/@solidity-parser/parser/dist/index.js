"use strict";

var _SolidityLexer = _interopRequireDefault(require("./lib/SolidityLexer"));

var _SolidityParser = _interopRequireDefault(require("./lib/SolidityParser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var antlr4 = require('antlr4');

var ASTBuilder = require('./ASTBuilder');

var ErrorListener = require('./ErrorListener');

var _require = require('./tokens'),
    buildTokenList = _require.buildTokenList;

function ParserError(args) {
  var _args$errors$ = args.errors[0],
      message = _args$errors$.message,
      line = _args$errors$.line,
      column = _args$errors$.column;
  this.message = "".concat(message, " (").concat(line, ":").concat(column, ")");
  this.errors = args.errors;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
}

ParserError.prototype = Object.create(Error.prototype);
ParserError.prototype.constructor = ParserError;
ParserError.prototype.name = 'ParserError';

function tokenize(input, options) {
  options = options || {};
  var chars = new antlr4.InputStream(input);
  var lexer = new _SolidityLexer["default"](chars);
  var tokens = new antlr4.CommonTokenStream(lexer);
  return buildTokenList(tokens.tokenSource.getAllTokens(), options);
}

function parse(input, options) {
  options = options || {};
  var chars = new antlr4.InputStream(input);
  var listener = new ErrorListener();
  var lexer = new _SolidityLexer["default"](chars);
  lexer.removeErrorListeners();
  lexer.addErrorListener(listener);
  var tokens = new antlr4.CommonTokenStream(lexer);
  var parser = new _SolidityParser["default"](tokens);
  parser.removeErrorListeners();
  parser.addErrorListener(listener);
  parser.buildParseTrees = true;
  var tree = parser.sourceUnit();
  var tokenList;

  if (options.tokens) {
    var tokenSource = tokens.tokenSource;
    tokenSource.reset();
    tokenList = buildTokenList(tokenSource.getAllTokens(), options);
  }

  if (!options.tolerant && listener.hasErrors()) {
    throw new ParserError({
      errors: listener.getErrors()
    });
  }

  var visitor = new ASTBuilder(options);
  var ast = visitor.visit(tree);

  if (options.tolerant && listener.hasErrors()) {
    ast.errors = listener.getErrors();
  }

  if (options.tokens) {
    ast.tokens = tokenList;
  }

  return ast;
}

function _isASTNode(node) {
  return !!node && _typeof(node) === 'object' && Object.prototype.hasOwnProperty.call(node, 'type');
}

function visit(node, visitor) {
  if (Array.isArray(node)) {
    node.forEach(function (child) {
      return visit(child, visitor);
    });
  }

  if (!_isASTNode(node)) return;
  var cont = true;

  if (visitor[node.type]) {
    cont = visitor[node.type](node);
  }

  if (cont === false) return;

  for (var prop in node) {
    if (Object.prototype.hasOwnProperty.call(node, prop)) {
      visit(node[prop], visitor);
    }
  }

  var selector = node.type + ':exit';

  if (visitor[selector]) {
    visitor[selector](node);
  }
}

exports.tokenize = tokenize;
exports.parse = parse;
exports.visit = visit;
exports.ParserError = ParserError;