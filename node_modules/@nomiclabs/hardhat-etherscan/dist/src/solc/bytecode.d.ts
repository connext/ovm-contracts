import { Artifacts, CompilerInput, CompilerOutput, CompilerOutputBytecode } from "hardhat/types";
import { InferralType } from "./version";
declare type BytecodeComparison = {
    match: false;
} | {
    match: true;
    contractInformation: BytecodeExtractedData;
};
interface BytecodeExtractedData {
    immutableValues: ImmutableValues;
    libraryLinks: ResolvedLinks;
    normalizedBytecode: string;
}
interface ResolvedLinks {
    [sourceName: string]: {
        [libraryName: string]: string;
    };
}
interface ImmutableValues {
    [key: string]: string;
}
declare type SourceName = string;
declare type ContractName = string;
export interface ContractInformation extends BytecodeExtractedData {
    compilerInput: CompilerInput;
    compilerOutput: CompilerOutput;
    solcVersion: string;
    sourceName: SourceName;
    contractName: ContractName;
    contract: CompilerOutput["contracts"][SourceName][ContractName];
}
export declare function lookupMatchingBytecode(artifacts: Artifacts, matchingVersions: string[], deployedBytecode: string, inferralType: InferralType): Promise<ContractInformation[]>;
export declare function compareBytecode(deployedBytecode: string, runtimeBytecodeSymbols: CompilerOutputBytecode, inferralType: InferralType): Promise<BytecodeComparison>;
export declare function normalizeBytecode(bytecode: string, symbols: CompilerOutputBytecode): Promise<BytecodeExtractedData>;
export {};
//# sourceMappingURL=bytecode.d.ts.map