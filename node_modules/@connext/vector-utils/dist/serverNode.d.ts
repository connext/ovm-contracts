import { EngineEvent, EngineEventMap, INodeService, Result, NodeParams, NodeResponses, OptionalPublicIdentifier, Values, NodeError } from "@connext/vector-types";
import { Evt } from "evt";
import { BaseLogger } from "pino";
export declare type EventCallbackConfig = {
    [event in keyof EngineEventMap]: {
        evt?: Evt<EngineEventMap[event]>;
        url?: string;
    };
};
export declare type ServerNodeServiceErrorContext = NodeError & {
    requestUrl: string;
    publicIdentifier: string;
    params: any;
};
export declare class ServerNodeServiceError extends NodeError {
    readonly msg: Values<typeof ServerNodeServiceError.reasons>;
    static readonly type = "ServerNodeServiceError";
    static readonly reasons: {
        readonly InternalServerError: "Failed to send request";
        readonly InvalidParams: "Request has invalid parameters";
        readonly MultinodeProhibitted: "Not allowed to have multiple nodes";
        readonly NoEvts: "No evts for event";
        readonly NoPublicIdentifier: "Public identifier not supplied, and no default identifier";
        readonly Timeout: "Timeout";
    };
    readonly context: ServerNodeServiceErrorContext;
    constructor(msg: Values<typeof ServerNodeServiceError.reasons>, publicIdentifier: string, requestUrl: string, params: any, context?: any);
}
export declare class RestServerNodeService implements INodeService {
    private readonly serverNodeUrl;
    private readonly logger;
    private readonly evts?;
    publicIdentifier: string;
    signerAddress: string;
    private readonly ctxs;
    private constructor();
    static connect(serverNodeUrl: string, logger: BaseLogger, evts?: EventCallbackConfig, index?: number, skipCheckIn?: boolean): Promise<RestServerNodeService>;
    getStatus(publicIdentifer?: string): Promise<Result<NodeResponses.GetStatus, ServerNodeServiceError>>;
    getRouterConfig(params: OptionalPublicIdentifier<NodeParams.GetRouterConfig>): Promise<Result<NodeResponses.GetRouterConfig, ServerNodeServiceError>>;
    getConfig(): Promise<Result<NodeResponses.GetConfig, ServerNodeServiceError>>;
    sendDisputeChannelTx(params: OptionalPublicIdentifier<NodeParams.SendDisputeChannelTx>): Promise<Result<NodeResponses.SendDisputeChannelTx, ServerNodeServiceError>>;
    sendDefundChannelTx(params: OptionalPublicIdentifier<NodeParams.SendDefundChannelTx>): Promise<Result<NodeResponses.SendDefundChannelTx, ServerNodeServiceError>>;
    sendDisputeTransferTx(params: OptionalPublicIdentifier<NodeParams.SendDisputeTransferTx>): Promise<Result<NodeResponses.SendDisputeTransferTx, ServerNodeServiceError>>;
    sendDefundTransferTx(params: OptionalPublicIdentifier<NodeParams.SendDefundTransferTx>): Promise<Result<NodeResponses.SendDefundTransferTx, ServerNodeServiceError>>;
    createNode(params: NodeParams.CreateNode): Promise<Result<NodeResponses.CreateNode, ServerNodeServiceError>>;
    getStateChannel(params: OptionalPublicIdentifier<NodeParams.GetChannelState>): Promise<Result<NodeResponses.GetChannelState, ServerNodeServiceError>>;
    getStateChannels(params: OptionalPublicIdentifier<NodeParams.GetChannelStates>): Promise<Result<NodeResponses.GetChannelStates, ServerNodeServiceError>>;
    getTransfersByRoutingId(params: OptionalPublicIdentifier<NodeParams.GetTransferStatesByRoutingId>): Promise<Result<NodeResponses.GetTransferStatesByRoutingId, ServerNodeServiceError>>;
    getTransferByRoutingId(params: OptionalPublicIdentifier<NodeParams.GetTransferStateByRoutingId>): Promise<Result<NodeResponses.GetTransferStateByRoutingId, ServerNodeServiceError>>;
    getTransfer(params: OptionalPublicIdentifier<NodeParams.GetTransferState>): Promise<Result<NodeResponses.GetTransferState, ServerNodeServiceError>>;
    getActiveTransfers(params: OptionalPublicIdentifier<NodeParams.GetActiveTransfersByChannelAddress>): Promise<Result<NodeResponses.GetActiveTransfersByChannelAddress, ServerNodeServiceError>>;
    getStateChannelByParticipants(params: OptionalPublicIdentifier<NodeParams.GetChannelStateByParticipants>): Promise<Result<NodeResponses.GetChannelStateByParticipants, ServerNodeServiceError>>;
    getRegisteredTransfers(params: OptionalPublicIdentifier<NodeParams.GetRegisteredTransfers>): Promise<Result<NodeResponses.GetRegisteredTransfers, ServerNodeServiceError>>;
    restoreState(params: OptionalPublicIdentifier<NodeParams.RestoreState>): Promise<Result<NodeResponses.RestoreState, ServerNodeServiceError>>;
    setup(params: OptionalPublicIdentifier<NodeParams.RequestSetup>): Promise<Result<NodeResponses.RequestSetup, ServerNodeServiceError>>;
    internalSetup(params: OptionalPublicIdentifier<NodeParams.Setup>): Promise<Result<NodeResponses.Setup, ServerNodeServiceError>>;
    sendDepositTx(params: OptionalPublicIdentifier<NodeParams.SendDepositTx>): Promise<Result<NodeResponses.SendDepositTx, ServerNodeServiceError>>;
    reconcileDeposit(params: OptionalPublicIdentifier<NodeParams.Deposit>): Promise<Result<NodeResponses.Deposit, ServerNodeServiceError>>;
    requestCollateral(params: OptionalPublicIdentifier<NodeParams.RequestCollateral>): Promise<Result<NodeResponses.RequestCollateral, ServerNodeServiceError>>;
    conditionalTransfer(params: OptionalPublicIdentifier<NodeParams.ConditionalTransfer>): Promise<Result<NodeResponses.ConditionalTransfer, ServerNodeServiceError>>;
    resolveTransfer(params: OptionalPublicIdentifier<NodeParams.ResolveTransfer>): Promise<Result<NodeResponses.ResolveTransfer, ServerNodeServiceError>>;
    withdraw(params: OptionalPublicIdentifier<NodeParams.Withdraw>): Promise<Result<NodeResponses.Withdraw, ServerNodeServiceError>>;
    signUtilityMessage(params: OptionalPublicIdentifier<NodeParams.SignUtilityMessage>): Promise<Result<NodeResponses.SignUtilityMessage, ServerNodeServiceError>>;
    sendIsAliveMessage(params: OptionalPublicIdentifier<NodeParams.SendIsAlive>): Promise<Result<NodeResponses.SendIsAlive, ServerNodeServiceError>>;
    once<T extends EngineEvent>(event: T, callback: (payload: EngineEventMap[T]) => void | Promise<void>, filter?: (payload: EngineEventMap[T]) => boolean, publicIdentifier?: string): void;
    on<T extends EngineEvent>(event: T, callback: (payload: EngineEventMap[T]) => void | Promise<void>, filter?: (payload: EngineEventMap[T]) => boolean, publicIdentifier?: string): void;
    waitFor<T extends EngineEvent>(event: T, timeout: number, filter?: (payload: EngineEventMap[T]) => boolean, publicIdentifier?: string): Promise<EngineEventMap[T] | undefined>;
    off<T extends EngineEvent>(event: T, publicIdentifier?: string): void;
    private executeHttpRequest;
}
//# sourceMappingURL=serverNode.d.ts.map