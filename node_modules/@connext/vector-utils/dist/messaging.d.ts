import { IChannelSigner, ChannelUpdate, IMessagingService, NodeError, LockInformation, Result, EngineParams, FullChannelState, FullTransferState, EngineError, VectorError, MessagingError, ProtocolError, RouterConfigResponse, IBasicMessaging, RouterError } from "@connext/vector-types";
import { BaseLogger } from "pino";
export { AuthService } from "ts-natsutil";
export declare type MessagingConfig = {
    messagingUrl?: string;
    authUrl?: string;
    natsUrl?: string;
    bearerToken?: string;
    signer?: IChannelSigner;
    logger?: BaseLogger;
};
export declare const getBearerToken: (authUrl: string, signer: IChannelSigner) => () => Promise<string>;
export declare class NatsBasicMessagingService implements IBasicMessaging {
    private connection;
    private log;
    private authUrl?;
    private bearerToken?;
    private natsUrl?;
    private signer?;
    constructor(config: MessagingConfig);
    private isConnected;
    assertConnected(): void;
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    publish(subject: string, data: any): Promise<void>;
    request(subject: string, timeout: number, data: any): Promise<any>;
    subscribe(subject: string, callback: (msg: any, err?: any) => void): Promise<void>;
    unsubscribe(subject: string): Promise<void>;
    flush(): Promise<void>;
    protected getSubjectsToUnsubscribeFrom(subject: string): string[];
    protected respondToMessage<T = any>(inbox: string, response: Result<T, Error>, method: string): Promise<void>;
    protected registerCallback<T = any>(subscriptionSubject: string, callback: (dataReceived: Result<T, VectorError>, from: string, inbox: string) => void, method: string): Promise<void>;
    private sendMessage;
    protected sendMessageWithRetries<T = any, R = any>(data: Result<T, any>, subjectSuffix: string, to: string, from: string, timeout: number, numRetries: number, method: string): Promise<Result<R, any>>;
    protected parseIncomingMessage<R>(msg: any): {
        result: Result<R, any>;
        parsed: any;
    };
}
export declare class NatsMessagingService extends NatsBasicMessagingService implements IMessagingService {
    private readonly config;
    private logger;
    constructor(config: MessagingConfig);
    sendProtocolMessage(channelUpdate: ChannelUpdate<any>, previousUpdate?: ChannelUpdate<any>, timeout?: number, numRetries?: number): Promise<Result<{
        update: ChannelUpdate<any>;
        previousUpdate: ChannelUpdate<any>;
    }, ProtocolError>>;
    onReceiveProtocolMessage(myPublicIdentifier: string, callback: (result: Result<{
        update: ChannelUpdate<any>;
        previousUpdate: ChannelUpdate<any>;
    }, ProtocolError>, from: string, inbox: string) => void): Promise<void>;
    respondToProtocolMessage(inbox: string, channelUpdate: ChannelUpdate<any>, previousUpdate?: ChannelUpdate<any>): Promise<void>;
    respondWithProtocolError(inbox: string, error: ProtocolError): Promise<void>;
    sendRestoreStateMessage(restoreData: Result<{
        chainId: number;
    } | {
        channelAddress: string;
    }, EngineError>, to: string, from: string, timeout?: number, numRetries?: number): Promise<Result<{
        channel: FullChannelState;
        activeTransfers: FullTransferState[];
    } | void, EngineError>>;
    onReceiveRestoreStateMessage(publicIdentifier: string, callback: (restoreData: Result<{
        chainId: number;
    } | {
        channelAddress: string;
    }, EngineError>, from: string, inbox: string) => void): Promise<void>;
    respondToRestoreStateMessage(inbox: string, restoreData: Result<{
        channel: FullChannelState;
        activeTransfers: FullTransferState[];
    } | void, EngineError>): Promise<void>;
    sendSetupMessage(setupInfo: Result<Omit<EngineParams.Setup, "counterpartyIdentifier">, Error>, to: string, from: string, timeout?: number, numRetries?: number): Promise<Result<{
        channelAddress: string;
    }, MessagingError>>;
    onReceiveSetupMessage(publicIdentifier: string, callback: (setupInfo: Result<Omit<EngineParams.Setup, "counterpartyIdentifier">, MessagingError>, from: string, inbox: string) => void): Promise<void>;
    respondToSetupMessage(inbox: string, params: Result<{
        channelAddress: string;
    }, Error>): Promise<void>;
    sendRequestCollateralMessage(requestCollateralParams: Result<EngineParams.RequestCollateral, VectorError>, to: string, from: string, timeout?: number, numRetries?: number): Promise<Result<undefined, VectorError>>;
    onReceiveRequestCollateralMessage(publicIdentifier: string, callback: (params: Result<EngineParams.RequestCollateral, VectorError>, from: string, inbox: string) => void): Promise<void>;
    respondToRequestCollateralMessage(inbox: string, params: Result<{
        message?: string;
    }, VectorError>): Promise<void>;
    sendLockMessage(lockInfo: Result<LockInformation, NodeError>, to: string, from: string, timeout?: number, numRetries?: number): Promise<Result<LockInformation, NodeError>>;
    onReceiveLockMessage(publicIdentifier: string, callback: (lockInfo: Result<LockInformation, NodeError>, from: string, inbox: string) => void): Promise<void>;
    respondToLockMessage(inbox: string, lockInformation: Result<LockInformation, NodeError>): Promise<void>;
    sendIsAliveMessage(isAlive: Result<{
        channelAddress: string;
        skipCheckIn?: boolean;
    }, VectorError>, to: string, from: string, timeout?: number, numRetries?: number): Promise<Result<{
        channelAddress: string;
    }, VectorError>>;
    onReceiveIsAliveMessage(publicIdentifier: string, callback: (isAlive: Result<{
        channelAddress: string;
        skipCheckIn?: boolean;
    }, VectorError>, from: string, inbox: string) => void): Promise<void>;
    respondToIsAliveMessage(inbox: string, params: Result<{
        channelAddress: string;
    }, VectorError>): Promise<void>;
    sendRouterConfigMessage(configRequest: Result<void, VectorError>, to: string, from: string, timeout?: number, numRetries?: number): Promise<Result<RouterConfigResponse, RouterError | MessagingError>>;
}
//# sourceMappingURL=messaging.d.ts.map