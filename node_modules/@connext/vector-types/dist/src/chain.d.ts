import { TransactionRequest, TransactionResponse } from "@ethersproject/abstract-provider";
import { BigNumber, BigNumberish } from "@ethersproject/bignumber";
import { Address, HexString } from "./basic";
import { Balance, FullChannelState, FullTransferState } from "./channel";
import { ChannelDispute } from "./dispute";
import { Result, Values, VectorError } from "./error";
import { ChainProviders, HydratedProviders } from "./network";
import { RegisteredTransfer, TransferName, TransferState } from "./transferDefinitions";
export declare const ERC20Abi: string[];
export declare class ChainError extends VectorError {
    readonly message: Values<typeof ChainError.reasons>;
    readonly context: any;
    static readonly type = "ChainError";
    static readonly reasons: {
        ProviderNotFound: string;
        SignerNotFound: string;
        SenderNotInChannel: string;
        NotEnoughFunds: string;
        FailedToDeploy: string;
        FailedToSendTx: string;
        TransferNotRegistered: string;
        MissingSigs: string;
        ResolverNeeded: string;
        NotInitialState: string;
        MultisigDeployed: string;
        TransferNotFound: string;
        TxReverted: string;
    };
    static readonly retryableTxErrors: {
        BadNonce: string;
        InvalidNonce: string;
        MissingHash: string;
        UnderpricedReplancement: string;
    };
    readonly canRetry: boolean;
    constructor(message: Values<typeof ChainError.reasons>, context?: any);
}
export declare type MinimalTransaction = {
    to: Address;
    value: BigNumberish;
    data: HexString;
};
export declare type MultisigTransaction = MinimalTransaction & {
    nonce: BigNumberish;
};
export interface IVectorChainReader {
    getChannelOnchainBalance(channelAddress: string, chainId: number, assetId: string): Promise<Result<BigNumber, ChainError>>;
    getTotalDepositedA(channelAddress: string, chainId: number, assetId: string): Promise<Result<BigNumber, ChainError>>;
    getTotalDepositedB(channelAddress: string, chainId: number, assetId: string): Promise<Result<BigNumber, ChainError>>;
    getChannelFactoryBytecode(channelFactoryAddress: string, chainId: number): Promise<Result<string, ChainError>>;
    getChannelMastercopyAddress(channelFactoryAddress: string, chainId: number): Promise<Result<string, ChainError>>;
    getChannelAddress(initiator: string, responder: string, channelFactoryAddress: string, chainId: number): Promise<Result<string, ChainError>>;
    getRegisteredTransferByName(name: TransferName, transferRegistry: string, chainId: number, bytecode?: string): Promise<Result<RegisteredTransfer, ChainError>>;
    getRegisteredTransferByDefinition(definition: Address, transferRegistry: string, chainId: number, bytecode?: string): Promise<Result<RegisteredTransfer, ChainError>>;
    getRegisteredTransfers(transferRegistry: string, chainId: number, bytecode?: string): Promise<Result<RegisteredTransfer[], ChainError>>;
    getChainProviders(): Result<ChainProviders, ChainError>;
    getHydratedProviders(): Result<HydratedProviders, ChainError>;
    create(initialState: TransferState, balance: Balance, transferDefinition: string, transferRegistryAddress: string, chainId: number, bytecode?: string): Promise<Result<boolean, ChainError>>;
    resolve(transfer: FullTransferState, chainId: number, bytecode?: string): Promise<Result<Balance, ChainError>>;
    getCode(address: Address, chainId: number): Promise<Result<string, ChainError>>;
    getBlockNumber(chainId: number): Promise<Result<number, ChainError>>;
    getGasPrice(chainId: number): Promise<Result<BigNumber, ChainError>>;
    estimateGas(chainId: number, transaction: TransactionRequest): Promise<Result<BigNumber, ChainError>>;
    getTokenAllowance(tokenAddress: string, owner: string, spender: string, chainId: number): Promise<Result<BigNumber, ChainError>>;
    getChannelDispute(channelAddress: string, chainId: number): Promise<Result<ChannelDispute | undefined, ChainError>>;
    getSyncing(chainId: number): Promise<Result<boolean | {
        startingBlock: string;
        currentBlock: string;
        highestBlock: string;
    }, ChainError>>;
}
export interface IVectorChainService extends IVectorChainReader {
    sendDepositTx(channelState: FullChannelState, sender: string, amount: string, assetId: string): Promise<Result<TransactionResponse, ChainError>>;
    sendWithdrawTx(channelState: FullChannelState, minTx: MinimalTransaction): Promise<Result<TransactionResponse, ChainError>>;
    sendDeployChannelTx(channelState: FullChannelState, gasPrice: BigNumber, deposit?: {
        amount: string;
        assetId: string;
    }): Promise<Result<TransactionResponse, ChainError>>;
    sendDisputeChannelTx(channelState: FullChannelState): Promise<Result<TransactionResponse, ChainError>>;
    sendDefundChannelTx(channelState: FullChannelState): Promise<Result<TransactionResponse, ChainError>>;
    sendDisputeTransferTx(transferIdToDispute: string, activeTransfers: FullTransferState[]): Promise<Result<TransactionResponse, ChainError>>;
    sendDefundTransferTx(transferState: FullTransferState): Promise<Result<TransactionResponse, ChainError>>;
}
//# sourceMappingURL=chain.d.ts.map