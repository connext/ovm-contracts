import { Type } from "@sinclair/typebox";
import { UpdateType } from "../channel";
export const TAddress = Type.RegEx(/^0x[a-fA-F0-9]{40}$/);
export const TIntegerString = Type.RegEx(/^([0-9])*$/);
export const TDecimalString = Type.RegEx(/^[0-9]*\.?[0-9]*$/);
export const TPublicIdentifier = Type.RegEx(/^vector([a-zA-Z0-9]{50})$/);
export const TBytes32 = Type.RegEx(/^0x([a-fA-F0-9]{64})$/);
export const TBytes = Type.RegEx(/^0x([a-fA-F0-9])$/);
export const TSignature = Type.RegEx(/^0x([a-fA-F0-9]{130})$/);
export const TUrl = Type.String({ format: "uri" });
export const TChainId = Type.Number({ minimum: 1 });
export const TBalance = Type.Object({
    to: Type.Array(TAddress),
    amount: Type.Array(TIntegerString),
});
export const TBasicMeta = Type.Optional(Type.Dict(Type.Any()));
export const TContractAddresses = Type.Object({
    channelFactoryAddress: TAddress,
    transferRegistryAddress: TAddress,
});
export const TNetworkContext = Type.Intersect([
    TContractAddresses,
    Type.Object({
        chainId: TChainId,
        providerUrl: TUrl,
    }),
]);
export const AllowedSwapSchema = Type.Object({
    fromChainId: TChainId,
    toChainId: TChainId,
    fromAssetId: TAddress,
    toAssetId: TAddress,
    priceType: Type.Union([Type.Literal("hardcoded")]),
    hardcodedRate: TDecimalString,
});
export const TransferStateSchema = Type.Dict(Type.Any());
export const TransferResolverSchema = Type.Any();
export const TransferEncodingSchema = Type.Array(Type.String(), { maxItems: 2, minItems: 2, uniqueItems: true });
export const TransferNameSchema = Type.String();
export const TFullTransferState = Type.Object({
    balance: TBalance,
    assetId: TAddress,
    channelAddress: TAddress,
    inDispute: Type.Boolean(),
    transferId: TBytes32,
    transferDefinition: TAddress,
    transferTimeout: TIntegerString,
    initialStateHash: TBytes32,
    initiator: TAddress,
    responder: TAddress,
    channelFactoryAddress: TAddress,
    chainId: TChainId,
    transferEncodings: TransferEncodingSchema,
    transferState: TransferStateSchema,
    transferResolver: Type.Optional(TransferResolverSchema),
    meta: TBasicMeta,
    channelNonce: Type.Integer({ minimum: 1 }),
    initiatorIdentifier: TPublicIdentifier,
    responderIdentifier: TPublicIdentifier,
});
export const TSetupUpdateDetails = Type.Object({
    timeout: TIntegerString,
    networkContext: TNetworkContext,
    meta: TBasicMeta,
});
export const TDepositUpdateDetails = Type.Object({
    totalDepositsAlice: TIntegerString,
    totalDepositsBob: TIntegerString,
    meta: TBasicMeta,
});
export const TCreateUpdateDetails = Type.Object({
    transferId: TBytes32,
    balance: TBalance,
    transferDefinition: TAddress,
    transferTimeout: TIntegerString,
    transferInitialState: TransferStateSchema,
    transferEncodings: TransferEncodingSchema,
    merkleProofData: Type.Array(Type.String()),
    merkleRoot: TBytes32,
    meta: TBasicMeta,
});
export const TResolveUpdateDetails = Type.Object({
    transferId: TBytes32,
    transferDefinition: TAddress,
    transferResolver: TransferResolverSchema,
    merkleRoot: TBytes32,
    meta: TBasicMeta,
});
export const TChannelUpdateDetails = Type.Union([
    TSetupUpdateDetails,
    TDepositUpdateDetails,
    TCreateUpdateDetails,
    TResolveUpdateDetails,
]);
export const TChannelUpdateType = Type.Union(Object.values(UpdateType).map((update) => Type.Literal(update)));
export const TChannelUpdate = Type.Object({
    channelAddress: TAddress,
    fromIdentifier: TPublicIdentifier,
    toIdentifier: TPublicIdentifier,
    type: TChannelUpdateType,
    nonce: Type.Number(),
    balance: TBalance,
    assetId: TAddress,
    details: Type.Dict(Type.Any()),
    aliceSignature: Type.Optional(Type.Union([TSignature, Type.Null()])),
    bobSignature: Type.Optional(Type.Union([TSignature, Type.Null()])),
});
export const TFullChannelState = Type.Object({
    assetIds: Type.Array(TAddress, { minItems: 1 }),
    balances: Type.Array(TBalance, { minItems: 1 }),
    channelAddress: TAddress,
    alice: TAddress,
    bob: TAddress,
    merkleRoot: TBytes,
    nonce: Type.Number(),
    processedDepositsA: Type.Array(TIntegerString),
    processedDepositsB: Type.Array(TIntegerString),
    timeout: TIntegerString,
    aliceIdentifier: TPublicIdentifier,
    bobIdentifier: TPublicIdentifier,
    latestUpdate: TChannelUpdate,
    networkContext: TNetworkContext,
    defundNonces: Type.Array(TIntegerString),
    inDispute: Type.Boolean(),
});
//# sourceMappingURL=basic.js.map