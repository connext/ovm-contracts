import { BigNumber } from '@ethersproject/bignumber';
import { Type } from '@sinclair/typebox';

const jsonifyError = (error) => {
    if (!!error.type) {
        return error.toJson();
    }
    return {
        message: error.message,
        type: error.name,
        context: {},
        stack: error.stack,
    };
};
class Result {
    constructor(error, value) {
        if (error) {
            this.isError = true;
            this.error = error;
        }
        else {
            this.isError = false;
            this.value = value;
        }
    }
    getValue() {
        if (this.isError) {
            throw new Error(`Can't getValue() of error result: ${this.error}`);
        }
        return this.value;
    }
    getError() {
        if (this.isError) {
            return this.error;
        }
        return undefined;
    }
    toJson() {
        if (!this.isError) {
            return { isError: false, value: this.value };
        }
        return {
            isError: true,
            error: jsonifyError(this.error),
        };
    }
    static fromJson(json) {
        if (!json.isError) {
            return Result.ok(json.value);
        }
        return json.error.type
            ? Result.fail(VectorError.fromJson(json.error))
            : Result.fail(json.error);
    }
    static fail(error) {
        return new Result(error);
    }
    static ok(result) {
        return new Result(undefined, result);
    }
}
class VectorError extends Error {
    constructor(msg, context = {}, type = "VectorError") {
        super(msg);
        this.msg = msg;
        this.context = context;
        this.type = type;
    }
    toJson() {
        return {
            message: this.msg,
            context: this.context,
            type: this.type,
            stack: this.stack,
        };
    }
    static fromJson(json) {
        return new VectorError(json.message, json.context, json.type);
    }
}
class MessagingError extends VectorError {
    constructor(message, context = {}, type = "MessagingError") {
        super(message, context, type);
        this.message = message;
        this.context = context;
        this.type = type;
    }
}
MessagingError.reasons = {
    Timeout: "Request timed out",
    Unknown: "Unknown messaging error",
};
class ProtocolError extends VectorError {
    constructor(msg, state, update, params, context = {}, type = "ProtocolError") {
        super(msg, Object.assign(Object.assign({}, context), { update, state, params }), type);
        this.msg = msg;
        this.type = type;
    }
}
class EngineError extends VectorError {
    constructor(msg, channelAddress, publicIdentifier, context = {}, type = "EngineError") {
        super(msg, Object.assign(Object.assign({}, context), { channelAddress, publicIdentifier }), type);
        this.msg = msg;
        this.type = type;
    }
}
class NodeError extends VectorError {
    constructor(msg, context = {}, type = "NodeError") {
        super(msg, Object.assign({}, context), type);
        this.msg = msg;
        this.type = type;
    }
}
class RouterError extends VectorError {
    constructor(msg, context = {}, type = "RouterError") {
        super(msg, Object.assign({}, context), type);
        this.msg = msg;
        this.type = type;
    }
}

const ERC20Abi = [
    "function balanceOf(address owner) view returns (uint256)",
    "function decimals() view returns (uint8)",
    "function symbol() view returns (string)",
    "function totalSupply() external view returns (uint256)",
    "function allowance(address owner, address spender) external view returns (uint256)",
    "function approve(address spender, uint256 amount) external returns (bool)",
    "function transfer(address to, uint amount) returns (boolean)",
    "function transferFrom(address sender, address recipient, uint256 amount) external returns (bool)",
    "event Transfer(address indexed from, address indexed to, uint amount)",
    "event Approval(address indexed owner, address indexed spender, uint256 value)",
];
class ChainError extends VectorError {
    constructor(message, context = {}) {
        super(message, context, ChainError.type);
        this.message = message;
        this.context = context;
        this.canRetry = Object.values(ChainError.retryableTxErrors).includes(this.message);
    }
}
ChainError.type = "ChainError";
ChainError.reasons = {
    ProviderNotFound: "Provider not found for chainId",
    SignerNotFound: "Signer not found for chainId",
    SenderNotInChannel: "Sender is not a channel participant",
    NotEnoughFunds: "Not enough funds in wallet",
    FailedToDeploy: "Could not deploy vector channel",
    FailedToSendTx: "Failed to send transaction to chain",
    TransferNotRegistered: "Transfer not in registry",
    MissingSigs: "Channel state is not double signed",
    ResolverNeeded: "Transfer resolver must be provided in dispute",
    NotInitialState: "Transfer must be disputed with initial state",
    MultisigDeployed: "Multisig already deployed",
    TransferNotFound: "Transfer is not included in active transfers",
    TxReverted: "Transaction reverted on chain",
};
ChainError.retryableTxErrors = {
    BadNonce: "the tx doesn't have the correct nonce",
    InvalidNonce: "Invalid nonce",
    MissingHash: "no transaction hash found in tx response",
    UnderpricedReplancement: "replacement transaction underpriced",
};

const enumify = (x) => x;
const tidy = (str) => `${str.replace(/\n/g, "").replace(/ +/g, " ")}`;

const BalanceEncoding = tidy(`tuple(
    uint256[2] amount,
    address[2] to
  )`);
const WithdrawDataEncoding = tidy(`tuple(
    address channelAddress,
    address assetId,
    address recipient,
    uint256 amount,
    uint256 nonce,
    address callTo,
    bytes callData
  )`);

const UpdateType = {
    create: "create",
    deposit: "deposit",
    resolve: "resolve",
    setup: "setup",
};
var ChannelCommitmentTypes;
(function (ChannelCommitmentTypes) {
    ChannelCommitmentTypes[ChannelCommitmentTypes["ChannelState"] = 0] = "ChannelState";
    ChannelCommitmentTypes[ChannelCommitmentTypes["WithdrawData"] = 1] = "WithdrawData";
})(ChannelCommitmentTypes || (ChannelCommitmentTypes = {}));
const CoreChannelStateEncoding = tidy(`tuple(
  address channelAddress,
  address alice,
  address bob,
  address[] assetIds,
  ${BalanceEncoding}[] balances,
  uint256[] processedDepositsA,
  uint256[] processedDepositsB,
  uint256[] defundNonces,
  uint256 timeout,
  uint256 nonce,
  bytes32 merkleRoot
)`);
const CoreTransferStateEncoding = tidy(`tuple(
  address channelAddress,
  bytes32 transferId,
  address transferDefinition,
  address initiator,
  address responder,
  address assetId,
  ${BalanceEncoding} balance,
  uint256 transferTimeout,
  bytes32 initialStateHash
)`);

const DEFAULT_TRANSFER_TIMEOUT = 60 * 60 * 24;
const MINIMUM_TRANSFER_TIMEOUT = DEFAULT_TRANSFER_TIMEOUT / 2;
const MAXIMUM_TRANSFER_TIMEOUT = DEFAULT_TRANSFER_TIMEOUT * 2;
const DEFAULT_CHANNEL_TIMEOUT = DEFAULT_TRANSFER_TIMEOUT * 2;
const MINIMUM_CHANNEL_TIMEOUT = DEFAULT_CHANNEL_TIMEOUT / 2;
const MAXIMUM_CHANNEL_TIMEOUT = DEFAULT_CHANNEL_TIMEOUT * 7;
const TRANSFER_DECREMENT = 60 * 72;
const UINT_MAX = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff").toString();
const ARBITRUM_TESTNET_1_CHAIN_ID = 152709604825713;
const AUTODEPLOY_CHAIN_IDS = [ARBITRUM_TESTNET_1_CHAIN_ID];

const IS_ALIVE_EVENT = "IS_ALIVE";
const SETUP_EVENT = "SETUP";
const CONDITIONAL_TRANSFER_CREATED_EVENT = "CONDITIONAL_TRANSFER_CREATED";
const CONDITIONAL_TRANSFER_RESOLVED_EVENT = "CONDITIONAL_TRANSFER_RESOLVED";
const DEPOSIT_RECONCILED_EVENT = "DEPOSIT_RECONCILED";
const REQUEST_COLLATERAL_EVENT = "REQUEST_COLLATERAL";
const WITHDRAWAL_CREATED_EVENT = "WITHDRAWAL_CREATED";
const WITHDRAWAL_RESOLVED_EVENT = "WITHDRAWAL_RESOLVED";
const WITHDRAWAL_RECONCILED_EVENT = "WITHDRAWAL_RECONCILED";
const RESTORE_STATE_EVENT = "RESTORE_STATE_EVENT";
const EngineEvents = {
    [IS_ALIVE_EVENT]: IS_ALIVE_EVENT,
    [SETUP_EVENT]: SETUP_EVENT,
    [CONDITIONAL_TRANSFER_CREATED_EVENT]: CONDITIONAL_TRANSFER_CREATED_EVENT,
    [CONDITIONAL_TRANSFER_RESOLVED_EVENT]: CONDITIONAL_TRANSFER_RESOLVED_EVENT,
    [DEPOSIT_RECONCILED_EVENT]: DEPOSIT_RECONCILED_EVENT,
    [REQUEST_COLLATERAL_EVENT]: REQUEST_COLLATERAL_EVENT,
    [RESTORE_STATE_EVENT]: RESTORE_STATE_EVENT,
    [SETUP_EVENT]: SETUP_EVENT,
    [WITHDRAWAL_CREATED_EVENT]: WITHDRAWAL_CREATED_EVENT,
    [WITHDRAWAL_RESOLVED_EVENT]: WITHDRAWAL_RESOLVED_EVENT,
    [WITHDRAWAL_RECONCILED_EVENT]: WITHDRAWAL_RECONCILED_EVENT,
};

const ProtocolEventName = {
    CHANNEL_UPDATE_EVENT: "CHANNEL_UPDATE_EVENT",
};

const TAddress = Type.RegEx(/^0x[a-fA-F0-9]{40}$/);
const TIntegerString = Type.RegEx(/^([0-9])*$/);
const TDecimalString = Type.RegEx(/^[0-9]*\.?[0-9]*$/);
const TPublicIdentifier = Type.RegEx(/^vector([a-zA-Z0-9]{50})$/);
const TBytes32 = Type.RegEx(/^0x([a-fA-F0-9]{64})$/);
const TBytes = Type.RegEx(/^0x([a-fA-F0-9])$/);
const TSignature = Type.RegEx(/^0x([a-fA-F0-9]{130})$/);
const TUrl = Type.String({ format: "uri" });
const TChainId = Type.Number({ minimum: 1 });
const TBalance = Type.Object({
    to: Type.Array(TAddress),
    amount: Type.Array(TIntegerString),
});
const TBasicMeta = Type.Optional(Type.Dict(Type.Any()));
const TContractAddresses = Type.Object({
    channelFactoryAddress: TAddress,
    transferRegistryAddress: TAddress,
});
const TNetworkContext = Type.Intersect([
    TContractAddresses,
    Type.Object({
        chainId: TChainId,
        providerUrl: TUrl,
    }),
]);
const AllowedSwapSchema = Type.Object({
    fromChainId: TChainId,
    toChainId: TChainId,
    fromAssetId: TAddress,
    toAssetId: TAddress,
    priceType: Type.Union([Type.Literal("hardcoded")]),
    hardcodedRate: TDecimalString,
});
const TransferStateSchema = Type.Dict(Type.Any());
const TransferResolverSchema = Type.Any();
const TransferEncodingSchema = Type.Array(Type.String(), { maxItems: 2, minItems: 2, uniqueItems: true });
const TransferNameSchema = Type.String();
const TFullTransferState = Type.Object({
    balance: TBalance,
    assetId: TAddress,
    channelAddress: TAddress,
    inDispute: Type.Boolean(),
    transferId: TBytes32,
    transferDefinition: TAddress,
    transferTimeout: TIntegerString,
    initialStateHash: TBytes32,
    initiator: TAddress,
    responder: TAddress,
    channelFactoryAddress: TAddress,
    chainId: TChainId,
    transferEncodings: TransferEncodingSchema,
    transferState: TransferStateSchema,
    transferResolver: Type.Optional(TransferResolverSchema),
    meta: TBasicMeta,
    channelNonce: Type.Integer({ minimum: 1 }),
    initiatorIdentifier: TPublicIdentifier,
    responderIdentifier: TPublicIdentifier,
});
const TSetupUpdateDetails = Type.Object({
    timeout: TIntegerString,
    networkContext: TNetworkContext,
    meta: TBasicMeta,
});
const TDepositUpdateDetails = Type.Object({
    totalDepositsAlice: TIntegerString,
    totalDepositsBob: TIntegerString,
    meta: TBasicMeta,
});
const TCreateUpdateDetails = Type.Object({
    transferId: TBytes32,
    balance: TBalance,
    transferDefinition: TAddress,
    transferTimeout: TIntegerString,
    transferInitialState: TransferStateSchema,
    transferEncodings: TransferEncodingSchema,
    merkleProofData: Type.Array(Type.String()),
    merkleRoot: TBytes32,
    meta: TBasicMeta,
});
const TResolveUpdateDetails = Type.Object({
    transferId: TBytes32,
    transferDefinition: TAddress,
    transferResolver: TransferResolverSchema,
    merkleRoot: TBytes32,
    meta: TBasicMeta,
});
const TChannelUpdateDetails = Type.Union([
    TSetupUpdateDetails,
    TDepositUpdateDetails,
    TCreateUpdateDetails,
    TResolveUpdateDetails,
]);
const TChannelUpdateType = Type.Union(Object.values(UpdateType).map((update) => Type.Literal(update)));
const TChannelUpdate = Type.Object({
    channelAddress: TAddress,
    fromIdentifier: TPublicIdentifier,
    toIdentifier: TPublicIdentifier,
    type: TChannelUpdateType,
    nonce: Type.Number(),
    balance: TBalance,
    assetId: TAddress,
    details: Type.Dict(Type.Any()),
    aliceSignature: Type.Optional(Type.Union([TSignature, Type.Null()])),
    bobSignature: Type.Optional(Type.Union([TSignature, Type.Null()])),
});
const TFullChannelState = Type.Object({
    assetIds: Type.Array(TAddress, { minItems: 1 }),
    balances: Type.Array(TBalance, { minItems: 1 }),
    channelAddress: TAddress,
    alice: TAddress,
    bob: TAddress,
    merkleRoot: TBytes,
    nonce: Type.Number(),
    processedDepositsA: Type.Array(TIntegerString),
    processedDepositsB: Type.Array(TIntegerString),
    timeout: TIntegerString,
    aliceIdentifier: TPublicIdentifier,
    bobIdentifier: TPublicIdentifier,
    latestUpdate: TChannelUpdate,
    networkContext: TNetworkContext,
    defundNonces: Type.Array(TIntegerString),
    inDispute: Type.Boolean(),
});

const VectorNodeConfigSchema = Type.Object({
    adminToken: Type.String(),
    authUrl: Type.Optional(Type.String({ format: "uri" })),
    chainAddresses: Type.Dict(TContractAddresses),
    chainProviders: Type.Dict(TUrl),
    dbUrl: Type.Optional(TUrl),
    logLevel: Type.Optional(Type.Union([
        Type.Literal("fatal"),
        Type.Literal("error"),
        Type.Literal("warn"),
        Type.Literal("info"),
        Type.Literal("debug"),
        Type.Literal("trace"),
        Type.Literal("silent"),
    ])),
    messagingUrl: Type.Optional(TUrl),
    mnemonic: Type.Optional(Type.String()),
    natsUrl: Type.Optional(TUrl),
    skipCheckIn: Type.Optional(Type.Boolean()),
});

const ChannelRpcMethods = {
    chan_signUtilityMessage: "chan_signUtilityMessage",
    chan_getConfig: "chan_getConfig",
    chan_getRouterConfig: "chan_getRouterConfig",
    chan_getStatus: "chan_getStatus",
    chan_getChannelState: "chan_getChannelState",
    chan_getChannelStateByParticipants: "chan_getChannelStateByParticipants",
    chan_getChannelStates: "chan_getChannelStates",
    chan_getTransferStateByRoutingId: "chan_getTransferStateByRoutingId",
    chan_getTransferStatesByRoutingId: "chan_getTransferStatesByRoutingId",
    chan_getActiveTransfers: "chan_getActiveTransfers",
    chan_getRegisteredTransfers: "chan_getRegisteredTransfers",
    chan_getTransferState: "chan_getTransferState",
    chan_setup: "chan_setup",
    chan_sendIsAlive: "chan_sendIsAlive",
    chan_requestSetup: "chan_requestSetup",
    chan_deposit: "chan_deposit",
    chan_requestCollateral: "chan_requestCollateral",
    chan_createTransfer: "chan_createTransfer",
    chan_resolveTransfer: "chan_resolveTransfer",
    chan_restoreState: "chan_restoreState",
    chan_withdraw: "chan_withdraw",
    chan_subscribe: "chan_subscribe",
    chan_unsubscribeAll: "chan_unsubscribeAll",
    connext_authenticate: "connext_authenticate",
    chan_dispute: "chan_dispute",
    chan_defund: "chan_defund",
    chan_disputeTransfer: "chan_disputeTransfer",
    chan_defundTransfer: "chan_defundTransfer",
    chan_decrypt: "chan_decrypt",
    chan_subscription: "chan_subscription",
};

const GetRouterConfigParamsSchema = Type.Object({
    routerIdentifier: TPublicIdentifier,
});
const GetTransferStateByRoutingIdParamsSchema = Type.Object({
    channelAddress: TAddress,
    routingId: TBytes32,
});
const GetTransferStatesByRoutingIdParamsSchema = Type.Object({
    routingId: TBytes32,
});
const GetChannelStateParamsSchema = Type.Object({ channelAddress: TAddress });
const GetChannelStatesParamsSchema = Type.Object({});
const GetChannelStateByParticipantsParamsSchema = Type.Object({
    alice: TPublicIdentifier,
    bob: TPublicIdentifier,
    chainId: TChainId,
});
const GetActiveTransfersParamsSchema = Type.Object({
    channelAddress: TAddress,
});
const GetTransferStateParamsSchema = Type.Object({
    transferId: TBytes32,
});
const GetRegisteredTransfersParamsSchema = Type.Object({
    chainId: TChainId,
});
const SetupEngineParamsSchema = Type.Object({
    counterpartyIdentifier: TPublicIdentifier,
    chainId: TChainId,
    timeout: TIntegerString,
    meta: Type.Optional(TBasicMeta),
});
const DepositEngineParamsSchema = Type.Object({
    channelAddress: TAddress,
    assetId: TAddress,
    meta: Type.Optional(TBasicMeta),
});
const RequestCollateralEngineParamsSchema = Type.Object({
    channelAddress: TAddress,
    assetId: TAddress,
    amount: Type.Optional(TIntegerString),
});
const CreateConditionalTransferParamsSchema = Type.Object({
    channelAddress: TAddress,
    amount: TIntegerString,
    assetId: TAddress,
    recipient: Type.Optional(TPublicIdentifier),
    recipientChainId: Type.Optional(TChainId),
    recipientAssetId: Type.Optional(TAddress),
    timeout: Type.Optional(TIntegerString),
    meta: Type.Optional(TBasicMeta),
    type: Type.String(),
    details: Type.Dict(Type.Any()),
});
const ResolveTransferParamsSchema = Type.Object({
    channelAddress: TAddress,
    transferId: TBytes32,
    meta: Type.Optional(TBasicMeta),
    transferResolver: TransferResolverSchema,
});
const WithdrawParamsSchema = Type.Object({
    channelAddress: TAddress,
    amount: TIntegerString,
    assetId: TAddress,
    recipient: TAddress,
    fee: Type.Optional(TIntegerString),
    callTo: Type.Optional(TAddress),
    callData: Type.Optional(Type.String()),
    meta: Type.Optional(TBasicMeta),
});
const DisputeChannelParamsSchema = Type.Object({
    channelAddress: TAddress,
});
const DefundChannelParamsSchema = Type.Object({
    channelAddress: TAddress,
});
const DisputeTransferParamsSchema = Type.Object({
    transferId: TBytes32,
});
const DefundTransferParamsSchema = Type.Object({
    transferId: TBytes32,
});
const SignUtilityMessageParamsSchema = Type.Object({
    message: Type.String(),
});
const SendIsAliveParamsSchema = Type.Object({ channelAddress: TAddress, skipCheckIn: Type.Boolean() });
const RestoreStateParamsSchema = Type.Object({
    counterpartyIdentifier: TPublicIdentifier,
    chainId: TChainId,
});
const RpcRequestEngineParamsSchema = Type.Object({
    id: Type.Number({ minimum: 1 }),
    jsonrpc: Type.Literal("2.0"),
    method: Type.Union(Object.values(ChannelRpcMethods).map((methodName) => Type.Literal(methodName))),
    params: Type.Optional(Type.Any()),
});
var EngineParams;
(function (EngineParams) {
    EngineParams.RpcRequestSchema = RpcRequestEngineParamsSchema;
    EngineParams.GetRouterConfigSchema = GetRouterConfigParamsSchema;
    EngineParams.SignUtilityMessageSchema = SignUtilityMessageParamsSchema;
    EngineParams.SendIsAliveSchema = SendIsAliveParamsSchema;
    EngineParams.GetTransferStateByRoutingIdSchema = GetTransferStateByRoutingIdParamsSchema;
    EngineParams.GetTransferStatesByRoutingIdSchema = GetTransferStatesByRoutingIdParamsSchema;
    EngineParams.GetChannelStatesSchema = GetChannelStatesParamsSchema;
    EngineParams.GetChannelStateSchema = GetChannelStateParamsSchema;
    EngineParams.GetChannelStateByParticipantsSchema = GetChannelStateByParticipantsParamsSchema;
    EngineParams.GetActiveTransfersSchema = GetActiveTransfersParamsSchema;
    EngineParams.GetTransferStateSchema = GetTransferStateParamsSchema;
    EngineParams.GetRegisteredTransfersSchema = GetRegisteredTransfersParamsSchema;
    EngineParams.SetupSchema = SetupEngineParamsSchema;
    EngineParams.RestoreStateSchema = RestoreStateParamsSchema;
    EngineParams.DepositSchema = DepositEngineParamsSchema;
    EngineParams.RequestCollateralSchema = RequestCollateralEngineParamsSchema;
    EngineParams.ConditionalTransferSchema = CreateConditionalTransferParamsSchema;
    EngineParams.ResolveTransferSchema = ResolveTransferParamsSchema;
    EngineParams.WithdrawSchema = WithdrawParamsSchema;
    EngineParams.DisputeChannelSchema = DisputeChannelParamsSchema;
    EngineParams.DefundChannelSchema = DefundChannelParamsSchema;
    EngineParams.DisputeTransferSchema = DisputeTransferParamsSchema;
    EngineParams.DefundTransferSchema = DefundTransferParamsSchema;
})(EngineParams || (EngineParams = {}));

const BasicChannelServerResponseSchema = {
    200: Type.Object({
        channelAddress: TAddress,
    }),
};
const BasicTransferServerResponseSchema = {
    200: Type.Object({
        channelAddress: TAddress,
        transferId: TBytes32,
        routingId: Type.Optional(TBytes32),
    }),
};
const GetRouterConfigParamsSchema$1 = Type.Intersect([
    EngineParams.GetRouterConfigSchema,
    Type.Object({
        publicIdentifier: TPublicIdentifier,
    }),
]);
const GetRouterConfigResponseSchema = {
    200: Type.Object({
        supportedChains: Type.Array(TChainId),
        allowedSwaps: Type.Array(AllowedSwapSchema),
    }),
};
const GetTransferStateByRoutingIdParamsSchema$1 = Type.Intersect([
    EngineParams.GetTransferStateByRoutingIdSchema,
    Type.Object({
        publicIdentifier: TPublicIdentifier,
    }),
]);
const GetTransferStateByRoutingIdResponseSchema = {
    200: Type.Union([Type.Undefined(), TFullTransferState]),
};
const GetTransferStatesByRoutingIdParamsSchema$1 = Type.Intersect([
    EngineParams.GetTransferStatesByRoutingIdSchema,
    Type.Object({
        publicIdentifier: TPublicIdentifier,
    }),
]);
const GetTransferStatesByRoutingIdResponseSchema = {
    200: Type.Array(TFullTransferState),
};
const GetActiveTransfersByChannelAddressParamsSchema = Type.Intersect([
    EngineParams.GetActiveTransfersSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const GetActiveTransfersByChannelAddressResponseSchema = {
    200: Type.Array(TFullTransferState),
};
const GetTransferStateParamsSchema$1 = Type.Intersect([
    EngineParams.GetTransferStateSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const GetTransferStateResponseSchema = {
    200: Type.Union([Type.Undefined(), TFullTransferState]),
};
const GetChannelStateParamsSchema$1 = Type.Intersect([
    EngineParams.GetChannelStateSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const GetChannelStateResponseSchema = {
    200: Type.Union([Type.Undefined(), TFullChannelState]),
};
const GetChannelStatesParamsSchema$1 = Type.Intersect([
    EngineParams.GetChannelStatesSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const GetChannelStatesResponseSchema = {
    200: Type.Array(TAddress),
};
const GetChannelStateByParticipantsParamsSchema$1 = Type.Object({
    publicIdentifier: TPublicIdentifier,
    counterparty: TPublicIdentifier,
    chainId: TChainId,
});
const GetChannelStateByParticipantsResponseSchema = GetChannelStateResponseSchema;
const GetConfigResponseSchema = {
    200: Type.Array(Type.Object({
        publicIdentifier: TPublicIdentifier,
        signerAddress: TAddress,
        index: Type.Integer(),
    })),
};
const GetStatusResponseSchema = {
    200: Type.Object({
        publicIdentifier: TPublicIdentifier,
        signerAddress: TAddress,
        providerSyncing: Type.Dict(Type.Union([
            Type.Boolean(),
            Type.Object({
                startingBlock: Type.String(),
                currentBlock: Type.String(),
                highestBlock: Type.String(),
            }),
            Type.String(),
            Type.Undefined(),
        ])),
        version: Type.String(),
    }),
};
const GetListenerParamsSchema = Type.Object({
    eventName: Type.Union(Object.values(EngineEvents).map((e) => Type.Literal(e))),
    publicIdentifier: TPublicIdentifier,
});
const GetListenerResponseSchema = {
    200: Type.Object({ url: TUrl }),
};
const GetListenersParamsSchema = Type.Object({ publicIdentifier: TPublicIdentifier });
const GetListenersResponseSchema = {
    200: Type.Dict(TUrl),
};
const GetRegisteredTransfersParamsSchema$1 = Type.Intersect([
    EngineParams.GetRegisteredTransfersSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const GetRegisteredTransfersResponseSchema = {
    200: Type.Array(Type.Object({
        name: Type.String(),
        stateEncoding: Type.String(),
        resolverEncoding: Type.String(),
        definition: TAddress,
        encodedCancel: Type.String(),
    })),
};
const PostRegisterListenerBodySchema = Type.Object({
    publicIdentifier: TPublicIdentifier,
    events: Type.Dict(Type.String()),
});
const PostRegisterListenerResponseSchema = {
    200: Type.Object({
        message: Type.String(),
    }),
};
const PostSetupBodySchema = Type.Intersect([
    EngineParams.SetupSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostSetupResponseSchema = BasicChannelServerResponseSchema;
const PostRequestSetupBodySchema = PostSetupBodySchema;
const PostRequestSetupResponseSchema = BasicChannelServerResponseSchema;
const PostDepositBodySchema = Type.Intersect([
    EngineParams.DepositSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostDepositResponseSchema = BasicChannelServerResponseSchema;
const PostRequestCollateralBodySchema = Type.Intersect([
    EngineParams.RequestCollateralSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostRequestCollateralResponseSchema = BasicChannelServerResponseSchema;
const PostSendDepositTxBodySchema = Type.Object({
    channelAddress: TAddress,
    amount: TIntegerString,
    assetId: TAddress,
    chainId: TChainId,
    publicIdentifier: TPublicIdentifier,
});
const PostSendDepositTxResponseSchema = {
    200: Type.Object({
        txHash: TBytes32,
    }),
};
const PostConditionalTransferBodySchema = Type.Intersect([
    EngineParams.ConditionalTransferSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostConditionalTransferResponseSchema = BasicTransferServerResponseSchema;
const PostResolveTransferBodySchema = Type.Intersect([
    EngineParams.ResolveTransferSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostResolveTransferResponseSchema = BasicTransferServerResponseSchema;
const PostWithdrawTransferBodySchema = Type.Intersect([
    EngineParams.WithdrawSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostWithdrawTransferResponseSchema = {
    200: Type.Object({
        channelAddress: TAddress,
        transferId: TBytes32,
        transactionHash: Type.Optional(TBytes32),
    }),
};
const PostSignUtilityMessageBodySchema = Type.Intersect([
    EngineParams.SignUtilityMessageSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostSignUtilityMessageResponseSchema = {
    200: Type.Object({
        signedMessage: Type.String(),
    }),
};
const PostRestoreStateBodySchema = Type.Intersect([
    EngineParams.RestoreStateSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostRestoreStateResponseSchema = {
    200: Type.Object({
        channelAddress: TAddress,
    }),
};
const PostCreateNodeBodySchema = Type.Object({
    index: Type.Integer({ minimum: 0, maximum: 2147483647 }),
    mnemonic: Type.Optional(Type.String()),
    skipCheckIn: Type.Optional(Type.Boolean()),
});
const PostCreateNodeResponseSchema = {
    200: Type.Object({
        publicIdentifier: TPublicIdentifier,
        signerAddress: TAddress,
        index: Type.Integer(),
    }),
};
const PostAdminBodySchema = Type.Object({
    adminToken: Type.String({
        example: "cxt1234",
        description: "Admin token",
    }),
});
const PostAdminResponseSchema = {
    200: Type.Object({
        message: Type.String(),
    }),
};
const PostAdminRetryWithdrawTransactionBodySchema = Type.Object({
    adminToken: Type.String(),
    transferId: TBytes32,
});
const PostAdminRetryWithdrawTransactionResponseSchema = {
    200: Type.Object({
        transferId: TBytes32,
        transactionHash: Type.String(),
    }),
};
const PostSendDisputeChannelTxBodySchema = Type.Intersect([
    EngineParams.DisputeChannelSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostSendDisputeChannelTxResponseSchema = {
    200: Type.Object({
        txHash: TBytes32,
    }),
};
const PostSendDefundChannelTxBodySchema = Type.Intersect([
    EngineParams.DefundChannelSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostSendDefundChannelTxResponseSchema = {
    200: Type.Object({
        txHash: TBytes32,
    }),
};
const PostSendDisputeTransferTxBodySchema = Type.Intersect([
    EngineParams.DisputeTransferSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostSendDisputeTransferTxResponseSchema = {
    200: Type.Object({
        txHash: TBytes32,
    }),
};
const PostSendDefundTransferTxBodySchema = Type.Intersect([
    EngineParams.DefundTransferSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostSendDefundTransferTxResponseSchema = {
    200: Type.Object({
        txHash: TBytes32,
    }),
};
const PostSendIsAliveBodySchema = Type.Intersect([
    EngineParams.SendIsAliveSchema,
    Type.Object({ publicIdentifier: TPublicIdentifier }),
]);
const PostSendIsAliveResponseSchema = {
    200: Type.Object({
        channelAddress: TAddress,
    }),
};
var NodeParams;
(function (NodeParams) {
    NodeParams.GetRouterConfigSchema = GetRouterConfigParamsSchema$1;
    NodeParams.GetTransferStateByRoutingIdSchema = GetTransferStateByRoutingIdParamsSchema$1;
    NodeParams.GetTransferStatesByRoutingIdSchema = GetTransferStatesByRoutingIdParamsSchema$1;
    NodeParams.GetTransferStateSchema = GetTransferStateParamsSchema$1;
    NodeParams.GetActiveTransfersByChannelAddressSchema = GetActiveTransfersByChannelAddressParamsSchema;
    NodeParams.GetChannelStateSchema = GetChannelStateParamsSchema$1;
    NodeParams.GetChannelStatesSchema = GetChannelStatesParamsSchema$1;
    NodeParams.GetChannelStateByParticipantsSchema = GetChannelStateByParticipantsParamsSchema$1;
    NodeParams.GetListenerSchema = GetListenerParamsSchema;
    NodeParams.GetListenersSchema = GetListenersParamsSchema;
    NodeParams.GetRegisteredTransfersSchema = GetRegisteredTransfersParamsSchema$1;
    NodeParams.GetConfigSchema = Type.Object({});
    NodeParams.SetupSchema = PostSetupBodySchema;
    NodeParams.RequestSetupSchema = PostRequestSetupBodySchema;
    NodeParams.DepositSchema = PostDepositBodySchema;
    NodeParams.RequestCollateralSchema = PostRequestCollateralBodySchema;
    NodeParams.SendDepositTxSchema = PostSendDepositTxBodySchema;
    NodeParams.ConditionalTransferSchema = PostConditionalTransferBodySchema;
    NodeParams.ResolveTransferSchema = PostResolveTransferBodySchema;
    NodeParams.WithdrawSchema = PostWithdrawTransferBodySchema;
    NodeParams.RegisterListenerSchema = PostRegisterListenerBodySchema;
    NodeParams.SignUtilityMessageSchema = PostSignUtilityMessageBodySchema;
    NodeParams.RestoreStateSchema = PostRestoreStateBodySchema;
    NodeParams.AdminSchema = PostAdminBodySchema;
    NodeParams.CreateNodeSchema = PostCreateNodeBodySchema;
    NodeParams.SendDisputeChannelTxSchema = PostSendDisputeChannelTxBodySchema;
    NodeParams.SendDefundChannelTxSchema = PostSendDefundChannelTxBodySchema;
    NodeParams.SendDisputeTransferTxSchema = PostSendDisputeTransferTxBodySchema;
    NodeParams.SendDefundTransferTxSchema = PostSendDefundTransferTxBodySchema;
    NodeParams.SendIsAliveSchema = PostSendIsAliveBodySchema;
    NodeParams.RetryWithdrawTransactionSchema = PostAdminRetryWithdrawTransactionBodySchema;
})(NodeParams || (NodeParams = {}));
var NodeResponses;
(function (NodeResponses) {
    NodeResponses.GetRouterConfigSchema = GetRouterConfigResponseSchema;
    NodeResponses.GetTransferStateByRoutingIdSchema = GetTransferStateByRoutingIdResponseSchema;
    NodeResponses.GetTransferStatesByRoutingIdSchema = GetTransferStatesByRoutingIdResponseSchema;
    NodeResponses.GetTransferStateSchema = GetTransferStateResponseSchema;
    NodeResponses.GetActiveTransfersByChannelAddressSchema = GetActiveTransfersByChannelAddressResponseSchema;
    NodeResponses.GetChannelStateSchema = GetChannelStateResponseSchema;
    NodeResponses.GetChannelStateByParticipantsSchema = GetChannelStateByParticipantsResponseSchema;
    NodeResponses.GetChannelStatesSchema = GetChannelStatesResponseSchema;
    NodeResponses.GetListenerSchema = GetListenerResponseSchema;
    NodeResponses.GetListenersSchema = GetListenersResponseSchema;
    NodeResponses.GetConfigSchema = GetConfigResponseSchema;
    NodeResponses.GetStatusSchema = GetStatusResponseSchema;
    NodeResponses.GetRegisteredTransfersSchema = GetRegisteredTransfersResponseSchema;
    NodeResponses.SetupSchema = PostSetupResponseSchema;
    NodeResponses.RequestSetupSchema = PostRequestSetupResponseSchema;
    NodeResponses.DepositSchema = PostDepositResponseSchema;
    NodeResponses.RequestCollateralSchema = PostRequestCollateralResponseSchema;
    NodeResponses.SendDepositTxSchema = PostSendDepositTxResponseSchema;
    NodeResponses.ConditionalTransferSchema = PostConditionalTransferResponseSchema;
    NodeResponses.ResolveTransferSchema = PostResolveTransferResponseSchema;
    NodeResponses.WithdrawSchema = PostWithdrawTransferResponseSchema;
    NodeResponses.RegisterListenerSchema = PostRegisterListenerResponseSchema;
    NodeResponses.SignUtilityMessageSchema = PostSignUtilityMessageResponseSchema;
    NodeResponses.RestoreStateSchema = PostRestoreStateResponseSchema;
    NodeResponses.AdminSchema = PostAdminResponseSchema;
    NodeResponses.CreateNodeSchema = PostCreateNodeResponseSchema;
    NodeResponses.SendDisputeChannelTxSchema = PostSendDisputeChannelTxResponseSchema;
    NodeResponses.SendDefundChannelTxSchema = PostSendDefundChannelTxResponseSchema;
    NodeResponses.SendDisputeTransferTxSchema = PostSendDisputeTransferTxResponseSchema;
    NodeResponses.SendDefundTransferTxSchema = PostSendDefundTransferTxResponseSchema;
    NodeResponses.SendIsAliveSchema = PostSendIsAliveResponseSchema;
    NodeResponses.RetryWithdrawTransactionSchema = PostAdminRetryWithdrawTransactionResponseSchema;
})(NodeResponses || (NodeResponses = {}));

const SetupProtocolParamsSchema = Type.Object({
    timeout: TIntegerString,
    networkContext: TNetworkContext,
    counterpartyIdentifier: TPublicIdentifier,
    meta: Type.Optional(TBasicMeta),
});
const DepositProtocolParamsSchema = Type.Object({
    channelAddress: TAddress,
    assetId: TAddress,
    meta: Type.Optional(TBasicMeta),
});
const CreateProtocolParamsSchema = Type.Object({
    channelAddress: TAddress,
    balance: TBalance,
    assetId: TAddress,
    transferDefinition: TAddress,
    transferInitialState: TransferStateSchema,
    timeout: TIntegerString,
    meta: Type.Optional(TBasicMeta),
});
const ResolveProtocolParamsSchema = Type.Object({
    channelAddress: TAddress,
    transferId: TBytes32,
    transferResolver: TransferResolverSchema,
    meta: Type.Optional(TBasicMeta),
});
var ProtocolParams;
(function (ProtocolParams) {
    ProtocolParams.SetupSchema = SetupProtocolParamsSchema;
    ProtocolParams.DepositSchema = DepositProtocolParamsSchema;
    ProtocolParams.CreateSchema = CreateProtocolParamsSchema;
    ProtocolParams.ResolveSchema = ResolveProtocolParamsSchema;
})(ProtocolParams || (ProtocolParams = {}));

const TPathSchema = Type.Object({
    recipient: TPublicIdentifier,
    recipientChainId: TChainId,
    recipientAssetId: TAddress,
});
const TRoutingMeta = Type.Object({
    routingId: TBytes32,
    requireOnline: Type.Boolean(),
    path: Type.Array(TPathSchema),
});
var RouterSchemas;
(function (RouterSchemas) {
    RouterSchemas.RouterMeta = TRoutingMeta;
})(RouterSchemas || (RouterSchemas = {}));

const StoredTransactionStatus = {
    submitted: "submitted",
    mined: "mined",
    failed: "failed",
};
const TransactionReason = {
    allowance: "allowance",
    approveTokens: "approveTokens",
    disputeChannel: "disputeChannel",
    disputeTransfer: "disputeTransfer",
    defundChannel: "defundChannel",
    defundTransfer: "defundTransfer",
    depositA: "depositA",
    depositB: "depositB",
    deploy: "deploy",
    deployWithDepositAlice: "deployWithDepositAlice",
    transferTokens: "transferTokens",
    withdraw: "withdraw",
};

const HashlockTransferName = "HashlockTransfer";
const HashlockTransferStateEncoding = tidy(`tuple(
    bytes32 lockHash,
    uint256 expiry
  )`);
const HashlockTransferResolverEncoding = tidy(`tuple(
    bytes32 preImage
  )`);

const WithdrawName = "Withdraw";
const WithdrawStateEncoding = tidy(`tuple(
    bytes initiatorSignature,
    address initiator,
    address responder,
    bytes32 data,
    uint256 nonce,
    uint256 fee,
    address callTo,
    bytes callData
  )`);
const WithdrawResolverEncoding = tidy(`tuple(
    bytes responderSignature
  )`);

const TransferNames = {
    [HashlockTransferName]: HashlockTransferName,
    [WithdrawName]: WithdrawName,
};
const TransferEncodingsMap = {
    [HashlockTransferName]: [HashlockTransferStateEncoding, HashlockTransferResolverEncoding],
    [WithdrawName]: [WithdrawStateEncoding, WithdrawResolverEncoding],
};

export { ARBITRUM_TESTNET_1_CHAIN_ID, AUTODEPLOY_CHAIN_IDS, AllowedSwapSchema, BalanceEncoding, CONDITIONAL_TRANSFER_CREATED_EVENT, CONDITIONAL_TRANSFER_RESOLVED_EVENT, ChainError, ChannelCommitmentTypes, ChannelRpcMethods, CoreChannelStateEncoding, CoreTransferStateEncoding, DEFAULT_CHANNEL_TIMEOUT, DEFAULT_TRANSFER_TIMEOUT, DEPOSIT_RECONCILED_EVENT, ERC20Abi, EngineError, EngineEvents, EngineParams, HashlockTransferName, HashlockTransferResolverEncoding, HashlockTransferStateEncoding, IS_ALIVE_EVENT, MAXIMUM_CHANNEL_TIMEOUT, MAXIMUM_TRANSFER_TIMEOUT, MINIMUM_CHANNEL_TIMEOUT, MINIMUM_TRANSFER_TIMEOUT, MessagingError, NodeError, NodeParams, NodeResponses, ProtocolError, ProtocolEventName, ProtocolParams, REQUEST_COLLATERAL_EVENT, RESTORE_STATE_EVENT, Result, RouterError, RouterSchemas, SETUP_EVENT, StoredTransactionStatus, TAddress, TBalance, TBasicMeta, TBytes, TBytes32, TChainId, TChannelUpdate, TChannelUpdateDetails, TChannelUpdateType, TContractAddresses, TCreateUpdateDetails, TDecimalString, TDepositUpdateDetails, TFullChannelState, TFullTransferState, TIntegerString, TNetworkContext, TPublicIdentifier, TRANSFER_DECREMENT, TResolveUpdateDetails, TSetupUpdateDetails, TSignature, TUrl, TransactionReason, TransferEncodingSchema, TransferEncodingsMap, TransferNameSchema, TransferNames, TransferResolverSchema, TransferStateSchema, UINT_MAX, UpdateType, VectorError, VectorNodeConfigSchema, WITHDRAWAL_CREATED_EVENT, WITHDRAWAL_RECONCILED_EVENT, WITHDRAWAL_RESOLVED_EVENT, WithdrawDataEncoding, WithdrawName, WithdrawResolverEncoding, WithdrawStateEncoding, enumify, jsonifyError, tidy };
