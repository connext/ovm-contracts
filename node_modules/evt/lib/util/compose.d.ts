import { Operator } from "../types/Operator";
export declare function compose<A, B, C, CtxResultOp1 = any, CtxResultOp2 = any>(op1: Operator.fλ<A, B, CtxResultOp1>, op2: Operator.fλ<B, C, CtxResultOp2>): Operator.fλ.Stateless<A, C, CtxResultOp1 | CtxResultOp2>;
export declare function compose<A, B, C extends B, CtxResult = any>(op1: Operator.fλ<A, B, CtxResult>, op2: (data: B) => data is C): Operator.fλ.Stateless<A, C, CtxResult>;
export declare function compose<A, B, CtxResult = any>(op1: Operator.fλ<A, B, CtxResult>, op2: (data: B) => boolean): Operator.fλ.Stateless<A, B, CtxResult>;
export declare function compose<A, B extends A, C, CtxResult = any>(op1: (data: A) => data is B, op2: Operator.fλ<B, C, CtxResult>): Operator.fλ.Stateless<A, B, CtxResult>;
export declare function compose<A, B, CtxResult = any>(op1: (data: A) => boolean, op2: Operator.fλ<A, B, CtxResult>): Operator.fλ.Stateless<A, B, CtxResult>;
export declare function compose<A, B extends A, C extends B>(op1: (data: A) => data is B, op2: (data: B) => data is C): Operator.fλ.Stateless<A, C, never>;
export declare function compose<A, B extends A>(op1: (data: A) => data is B, op2: (data: B) => boolean): Operator.fλ.Stateless<A, B, never>;
export declare function compose<A, B extends A>(op1: (data: A) => boolean, op2: (data: A) => data is B): Operator.fλ.Stateless<A, B, never>;
export declare function compose<A>(op1: (data: A) => boolean, op2: (data: A) => boolean): Operator.fλ.Stateless<A, A, never>;
export declare function compose<A, B, C, D, CtxResultOp1 = any, CtxResultOp2 = any, CtxResultOp3 = any>(op1: Operator.fλ<A, B, CtxResultOp1>, op2: Operator.fλ<B, C, CtxResultOp2>, op3: Operator.fλ<C, D, CtxResultOp3>): Operator.fλ.Stateless<A, D, CtxResultOp1 | CtxResultOp2 | CtxResultOp3>;
export declare function compose<A, B, C, D, E, CtxResultOp1 = any, CtxResultOp2 = any, CtxResultOp3 = any, CtxResultOp4 = any>(op1: Operator.fλ<A, B, CtxResultOp1>, op2: Operator.fλ<B, C, CtxResultOp2>, op3: Operator.fλ<C, D, CtxResultOp3>, op4: Operator.fλ<D, E, CtxResultOp4>): Operator.fλ.Stateless<A, E, CtxResultOp1 | CtxResultOp2 | CtxResultOp3 | CtxResultOp4>;
export declare function compose<A, B, C, D, E, CtxResultOp1 = any, CtxResultOp2 = any, CtxResultOp3 = any, CtxResultOp4 = any>(op1: Operator.fλ<A, B, CtxResultOp1>, op2: Operator.fλ<B, C, CtxResultOp2>, op3: Operator.fλ<C, D, CtxResultOp3>, op4: Operator.fλ<D, E, CtxResultOp4>): Operator.fλ.Stateless<A, E, CtxResultOp1 | CtxResultOp2 | CtxResultOp3 | CtxResultOp4>;
export declare function compose<A, B, C, D, E, F, CtxResultOp1 = any, CtxResultOp2 = any, CtxResultOp3 = any, CtxResultOp4 = any, CtxResultOp5 = any>(op1: Operator.fλ<A, B, CtxResultOp1>, op2: Operator.fλ<B, C, CtxResultOp2>, op3: Operator.fλ<C, D, CtxResultOp3>, op4: Operator.fλ<D, E, CtxResultOp4>, op5: Operator.fλ<E, F, CtxResultOp5>): Operator.fλ.Stateless<A, F, CtxResultOp1 | CtxResultOp2 | CtxResultOp3 | CtxResultOp4 | CtxResultOp5>;
export declare function compose<A, B, C, CtxResultOp1 = any, CtxResultOp2 = any>(op1: Operator<A, B, CtxResultOp1>, op2: Operator<B, C, CtxResultOp2>): Operator.fλ.Stateless<A, C, CtxResultOp1 | CtxResultOp2>;
export declare function compose<A, B, C, D, CtxResultOp1 = any, CtxResultOp2 = any, CtxResultOp3 = any>(op1: Operator<A, B, any>, op2: Operator<B, C, any>, op3: Operator<C, D, any>): Operator.fλ.Stateless<A, D, CtxResultOp1 | CtxResultOp2 | CtxResultOp3>;
export declare function compose<A, B, C, D, E, CtxResultOp1 = any, CtxResultOp2 = any, CtxResultOp3 = any, CtxResultOp4 = any, CtxResultOp5 = any>(op1: Operator<A, B, CtxResultOp1>, op2: Operator<B, C, CtxResultOp2>, op3: Operator<C, D, CtxResultOp3>, op4: Operator<D, E, CtxResultOp4>): Operator.fλ.Stateless<A, E, CtxResultOp1 | CtxResultOp2 | CtxResultOp3 | CtxResultOp4 | CtxResultOp5>;
export declare function compose<A, B, C, D, E, F, CtxResultOp1 = any, CtxResultOp2 = any, CtxResultOp3 = any, CtxResultOp4 = any, CtxResultOp5 = any>(op1: Operator<A, B, CtxResultOp1>, op2: Operator<B, C, CtxResultOp2>, op3: Operator<C, D, CtxResultOp3>, op4: Operator<D, E, CtxResultOp4>, op5: Operator<E, F, CtxResultOp5>): Operator.fλ.Stateless<A, F, CtxResultOp1 | CtxResultOp2 | CtxResultOp3 | CtxResultOp4 | CtxResultOp5>;
export declare function compose<T>(...ops: [Operator<T, any, any>, ...Operator<any, any, any>[]]): Operator.Stateless<T, any, any>;
